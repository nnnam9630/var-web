<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gh√©p ƒë√¥i Camera VAR</title>
    <!-- T·∫£i Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- T·∫£i PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    
    <!-- T·∫£i TensorFlow.js v√† c√°c model AI -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest/dist/coco-ssd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@latest/dist/blazeface.min.js"></script>
    
    <!-- T·∫£i Font OPPOSans -->
    <link href="https://cdn.jsdelivr.net/gh/Zhonglin-L/Fonts/OPPOSans/OPPOSans.css" rel="stylesheet">
    
    <style>
        body {
            font-family: 'OPPOSans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        /* S·ª¨A L·ªñI: Thu nh·ªè √¥ nh·∫≠p li·ªáu ƒë·ªÉ v·ª´a v·ªõi c·ªôt 1/3 */
        #pairCodeInput input {
            width: 2.2em;  /* Thu nh·ªè l·∫°i */
            height: 3.2em; /* Thu nh·ªè l·∫°i */
            text-align: center;
            font-size: 1.25rem; /* Thu nh·ªè ch·ªØ */
            font-weight: bold;
            border-radius: 0.5rem;
            margin: 0 0.15rem; /* Gi·∫£m kho·∫£ng c√°ch */
            border: 2px solid #4b5563; /* border-gray-600 */
            background-color: #374151; /* bg-gray-700 */
            color: white;
            transition: all 0.2s;
        }
        #pairCodeInput input:focus {
            border-color: #3b82f6; /* border-blue-500 */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
            outline: none;
        }
        /* T·ª∑ l·ªá 16:9 cho video preview */
        .video-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            background-color: #000;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        #localPreview, #detectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* D√πng 'cover' ƒë·ªÉ l·∫•p ƒë·∫ßy khung 16:9 */
            object-fit: cover; 
        }
        #detectionCanvas {
            pointer-events: none; /* Cho ph√©p click xuy√™n qua */
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans antialiased flex items-center justify-center min-h-screen p-4">

    <!-- C·∫•u tr√∫c m·ªõi cho b·ªë c·ª•c 2 c·ªôt tr√™n desktop -->
    <div class="w-full max-w-4xl"> <!-- TƒÉng max-width cho b·ªë c·ª•c r·ªông h∆°n -->
        <div class="bg-gray-800 rounded-lg shadow-2xl p-6">
            <h1 class="text-2xl font-bold text-center text-blue-400 mb-6">Gh√©p ƒë√¥i Camera VAR</h1>
            
            <!-- Hi·ªÉn th·ªã l·ªói -->
            <div id="errorMessage" class="hidden bg-red-800 border border-red-600 text-red-200 px-4 py-3 rounded-lg mb-4">
                <p id="errorText"></p>
            </div>
            
            <!-- Hi·ªÉn th·ªã tr·∫°ng th√°i -->
            <div id="statusMessage" class="hidden bg-blue-800 border border-blue-600 text-blue-200 px-4 py-3 rounded-lg mb-4">
                <p id="statusText"></p>
            </div>
            
            <!-- B·ªë c·ª•c Flex (lg:flex-row) -->
            <div class="flex flex-col lg:flex-row lg:gap-6">
            
                <!-- C·ªôt tr√°i: Camera Preview -->
                <div class="lg:w-2/3 w-full">
                    <!-- Video Preview (16:9) -->
                    <div class="video-wrapper mb-4">
                        <video id="localPreview" autoplay muted playsinline class="hidden"></video>
                        <canvas id="detectionCanvas"></canvas>
                        <div id="videoLoading" class="w-full h-full flex items-center justify-center">
                            <span class="text-gray-400">ƒêang b·∫≠t camera...</span>
                        </div>
                    </div>
                    <!-- N√∫t B·∫≠t/T·∫Øt Detect (chuy·ªÉn xu·ªëng d∆∞·ªõi video) -->
                    <button id="btnToggleDetection" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 mb-4 lg:mb-0" disabled>
                        ü§ñ B·∫≠t Detect
                    </button>
                </div>
                
                <!-- C·ªôt ph·∫£i: Form Nh·∫≠p m√£ -->
                <div id="entryForm" class="lg:w-1/3 w-full flex flex-col justify-center">
                    <label class="block text-gray-400 text-sm mb-2 text-center" for="pairCodeInput">Nh·∫≠p m√£ gh√©p ƒë√¥i (6 ch·ªØ c√°i):</label>
                    <div id="pairCodeInput" class="flex justify-center mb-4">
                        <input type="text" maxlength="1" data-index="0" class="uppercase">
                        <input type="text" maxlength="1" data-index="1" class="uppercase">
                        <input type="text" maxlength="1" data-index="2" class="uppercase">
                        <input type="text" maxlength="1" data-index="3" class="uppercase">
                        <input type="text" maxlength="1" data-index="4" class="uppercase">
                        <input type="text" maxlength="1" data-index="5" class="uppercase">
                    </div>

                    <button id="btnConnect" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 disabled:opacity-50" disabled>
                        <span id="btnConnectText">ƒêang t·∫£i...</span>
                    </button>
                </div>
                
            </div> <!-- K·∫øt th√∫c flex 2 c·ªôt -->
            
        </div>
    </div>

    <script type="module">
        let peer = null;
        let localStream = null;
        
        // Bi·∫øn AI
        let faceModel = null;
        let objectModel = null;
        let isDetectionRunning = false; // T·∫Øt theo m·∫∑c ƒë·ªãnh
        let detectionInterval = null;
        
        const localPreview = document.getElementById('localPreview');
        const videoLoading = document.getElementById('videoLoading');
        const detectionCanvas = document.getElementById('detectionCanvas');
        const detCtx = detectionCanvas.getContext('2d');
        
        const btnToggleDetection = document.getElementById('btnToggleDetection');
        
        const btnConnect = document.getElementById('btnConnect');
        const btnConnectText = document.getElementById('btnConnectText');
        const entryForm = document.getElementById('entryForm');
        
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const statusMessage = document.getElementById('statusMessage');
        const statusText = document.getElementById('statusText');
        
        const codeInputs = [...document.querySelectorAll('#pairCodeInput input')];

        /**
         * Ph√°t video an to√†n
         */
        async function playVideoSafe(videoElement) {
            if (!videoElement) return;
            videoElement.muted = true;
            try {
                await videoElement.play();
            } catch (error) {
                if (error.name !== 'AbortError' && !error.message.includes('interrupted')) {
                    console.error("L·ªói ph√°t video preview:", error);
                }
            }
        }
        
        /**
         * Hi·ªÉn th·ªã l·ªói
         */
        function showError(message) {
            statusMessage.classList.add('hidden');
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        /**
         * Hi·ªÉn th·ªã tr·∫°ng th√°i
         */
        function showStatus(message) {
            errorMessage.classList.add('hidden');
            statusText.textContent = message;
            statusMessage.classList.remove('hidden');
        }

        /**
         * 1. Kh·ªüi t·∫°o PeerJS
         */
        function initializePeer() {
             try {
                peer = new Peer({ debug: 2 }); // Kh·ªüi t·∫°o v·ªõi ID ng·∫´u nhi√™n

                peer.on('open', (id) => {
                    console.log('PeerJS ƒë√£ s·∫µn s√†ng. ID c·ªßa t√¥i l√†:', id);
                    btnConnectText.textContent = 'K·∫øt n·ªëi';
                    btnConnect.disabled = false; // K√çCH HO·∫†T N√öT
                });

                peer.on('error', (err) => {
                    console.error('L·ªói PeerJS:', err);
                    showError(`L·ªói k·∫øt n·ªëi: ${err.message}`);
                    btnConnectText.textContent = 'Th·ª≠ l·∫°i';
                    btnConnect.disabled = false;
                });
            } catch (e) {
                 console.error("Kh√¥ng th·ªÉ t·∫£i PeerJS. Ki·ªÉm tra k·∫øt n·ªëi.", e);
                 showError("Kh√¥ng th·ªÉ t·∫£i th∆∞ vi·ªán k·∫øt n·ªëi. Vui l√≤ng t·∫£i l·∫°i trang.");
            }
        }

        /**
         * 2. Kh·ªüi t·∫°o Camera
         */
        async function startCamera() {
            try {
                // Y√™u c·∫ßu t·ª∑ l·ªá 16:9
                const constraints = {
                    video: {
                        aspectRatio: 16/9,
                        width: { ideal: 1280 },
                        facingMode: "environment" // Camera sau
                    },
                    audio: false // Kh√¥ng c·∫ßn audio
                };

                // Th·ª≠ l·∫•y 16:9 tr∆∞·ªõc
                try {
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                } catch (e1) {
                    console.warn("Kh√¥ng th·ªÉ l·∫•y camera 16:9, th·ª≠ l·∫°i v·ªõi c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh...", e1.name);
                    // N·∫øu th·∫•t b·∫°i (v√≠ d·ª•: camera kh√¥ng h·ªó tr·ª£ 16:9), th·ª≠ l·∫°i m√† kh√¥ng c√≥ y√™u c·∫ßu t·ª∑ l·ªá
                    const fallbackConstraints = {
                        video: {
                            width: { ideal: 1280 },
                            facingMode: "environment"
                        },
                        audio: false
                    };
                    try {
                         localStream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
                    } catch (e2) {
                        console.warn("Th·∫•t b·∫°i l·∫ßn 2, th·ª≠ v·ªõi camera tr∆∞·ªõc...", e2.name);
                        // Th·ª≠ l·∫°i v·ªõi camera tr∆∞·ªõc
                         localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                    }
                }
                
                localPreview.srcObject = localStream;
                localPreview.classList.remove('hidden');
                videoLoading.classList.add('hidden');
                
                await playVideoSafe(localPreview);
                
                // Kh·ªüi ch·∫°y AI sau khi camera b·∫≠t
                if (detectionInterval) clearInterval(detectionInterval);
                detectionInterval = setInterval(runDetection, 100);

            } catch (err) {
                console.error("L·ªói b·∫≠t camera:", err);
                videoLoading.classList.add('hidden');
                if (err.name === "NotAllowedError") {
                    showError("B·∫°n ƒë√£ t·ª´ ch·ªëi quy·ªÅn truy c·∫≠p camera.");
                } else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") {
                    showError("Kh√¥ng t√¨m th·∫•y camera tr√™n thi·∫øt b·ªã n√†y.");
                } else {
                    showError("Kh√¥ng th·ªÉ b·∫≠t camera. Vui l√≤ng th·ª≠ l·∫°i.");
                }
            }
        }
        
        /**
         * 3. Kh·ªüi t·∫°o AI Models
         */
        async function loadModels() {
            try {
                if (!window.tf || !window.blazeface || !window.cocoSsd) {
                    console.error("Thi·∫øu th∆∞ vi·ªán TensorFlow.js ho·∫∑c models.");
                    showError("L·ªói t·∫£i th∆∞ vi·ªán AI.");
                    return;
                }
            
                showStatus('ƒêang t·∫£i model AI (ph√°t hi·ªán b√≥ng)...');
                await tf.setBackend('webgl');
                
                objectModel = await cocoSsd.load();
                
                showStatus('ƒêang t·∫£i model AI (ph√°t hi·ªán khu√¥n m·∫∑t)...');
                faceModel = await blazeface.load();
                
                console.log("ƒê√£ t·∫£i xong 2 model AI (BlazeFace & COCO-SSD).");
                showStatus('AI ƒë√£ s·∫µn s√†ng. Ch·ªù k·∫øt n·ªëi...');
                
                // K√≠ch ho·∫°t n√∫t Detect
                btnToggleDetection.disabled = false;
                
            } catch (err) {
                console.error("L·ªói t·∫£i model AI:", err);
                showError("L·ªói t·∫£i model AI. T√≠nh nƒÉng ph√°t hi·ªán c√≥ th·ªÉ kh√¥ng ho·∫°t ƒë·ªông.");
            }
        }
        
        /**
         * 4. Ch·∫°y AI Detection
         */
        async function runDetection() {
            // Ki·ªÉm tra c·ªù isDetectionRunning
            if (!isDetectionRunning || (!faceModel && !objectModel) || !detCtx || !localPreview) {
                 if (detCtx) detCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
                return;
            }
                
            const sourceElement = localPreview;
            
            if (sourceElement.paused || sourceElement.ended || sourceElement.readyState < 2) {
                detCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
                return;
            }

            const p1 = faceModel ? faceModel.estimateFaces(sourceElement, false) : Promise.resolve([]);
            const p2 = objectModel ? objectModel.detect(sourceElement) : Promise.resolve([]);
            
            const [facePredictions, objectPredictions] = await Promise.all([p1, p2]);

            // S·ª¨A L·ªñI: T√≠nh to√°n t·ª∑ l·ªá cho 'object-cover'
            const videoRatio = sourceElement.videoWidth / sourceElement.videoHeight;
            const canvasRatio = detCtx.canvas.clientWidth / detCtx.canvas.clientHeight;
            let scale = 1, offsetX = 0, offsetY = 0;

            if (videoRatio > canvasRatio) {
                // Video r·ªông h∆°n canvas -> Video b·ªã c·∫Øt tr√°i/ph·∫£i (pillarbox)
                scale = detCtx.canvas.clientHeight / sourceElement.videoHeight;
                offsetX = (detCtx.canvas.clientWidth - sourceElement.videoWidth * scale) / 2;
                offsetY = 0;
            } else {
                // Video cao h∆°n canvas -> Video b·ªã c·∫Øt tr√™n/d∆∞·ªõi (letterbox)
                scale = detCtx.canvas.clientWidth / sourceElement.videoWidth;
                offsetX = 0;
                offsetY = (detCtx.canvas.clientHeight - sourceElement.videoHeight * scale) / 2;
            }
            
            detectionCanvas.width = detCtx.canvas.clientWidth;
            detectionCanvas.height = detCtx.canvas.clientHeight;

            detCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            detCtx.font = '16px sans-serif';
            detCtx.textBaseline = 'top';
            
            facePredictions.forEach(pred => {
                const [startX, startY] = pred.topLeft;
                const [endX, endY] = pred.bottomRight;
                const width = endX - startX;
                const height = endY - startY;

                const x = startX * scale + offsetX;
                const y = startY * scale + offsetY;
                const w = width * scale;
                const h = height * scale;

                detCtx.strokeStyle = '#32CD32'; // Xanh l√°
                detCtx.lineWidth = 2;
                detCtx.strokeRect(x, y, w, h);
                
                detCtx.fillStyle = '#32CD32';
                detCtx.fillText('Face', x, y > 18 ? y - 18 : y + h + 4);
            });
            
            objectPredictions.forEach(pred => {
                if (pred.class === 'sports ball') {
                    const [startX, startY, width, height] = pred.bbox;
                    
                    const x = startX * scale + offsetX;
                    const y = startY * scale + offsetY;
                    const w = width * scale;
                    const h = height * scale;

                    detCtx.strokeStyle = '#FFD700'; // V√†ng
                    detCtx.lineWidth = 2;
                    detCtx.strokeRect(x, y, w, h);
                    
                    detCtx.fillStyle = '#FFD700';
                    const label = `Ball (${Math.round(pred.score * 100)}%)`;
                    detCtx.fillText(label, x, y > 18 ? y - 18 : y + h + 4);
                }
            });
        }
        
        /**
         * 5. X·ª≠ l√Ω logic nh·∫≠p m√£
         */
        codeInputs.forEach(input => {
            input.addEventListener('input', (e) => {
                const value = input.value.toUpperCase();
                input.value = value;
                
                const index = parseInt(input.dataset.index, 10);
                if (value && index < codeInputs.length - 1) {
                    codeInputs[index + 1].focus();
                }
            });

            input.addEventListener('keydown', (e) => {
                const index = parseInt(input.dataset.index, 10);
                if (e.key === 'Backspace' && !input.value && index > 0) {
                    codeInputs[index - 1].focus();
                }
            });

            input.addEventListener('paste', (e) => {
                e.preventDefault();
                const pasteData = e.clipboardData.getData('text').toUpperCase();
                if (pasteData.length === codeInputs.length) {
                    codeInputs.forEach((input, index) => {
                        input.value = pasteData[index] || '';
                    });
                    codeInputs[codeInputs.length - 1].focus();
                }
            });
        });

        /**
         * 6. X·ª≠ l√Ω n√∫t K·∫øt n·ªëi v√† B·∫≠t/T·∫Øt Detect
         */
        if (btnToggleDetection) {
            btnToggleDetection.addEventListener('click', () => {
                isDetectionRunning = !isDetectionRunning; // B·∫≠t/t·∫Øt c·ªù
                
                if (isDetectionRunning) {
                    btnToggleDetection.textContent = 'üõë T·∫Øt Detect';
                    btnToggleDetection.classList.add('bg-red-600', 'hover:bg-red-700');
                    btnToggleDetection.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                } else {
                    btnToggleDetection.textContent = 'ü§ñ B·∫≠t Detect';
                    btnToggleDetection.classList.remove('bg-red-600', 'hover:bg-red-700');
                    btnToggleDetection.classList.add('bg-purple-600', 'hover:bg-purple-700');
                    if (detCtx) detCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
                }
            });
        }
         
        if (btnConnect) {
            btnConnect.addEventListener('click', () => {
                if (!peer) {
                    showError("K·∫øt n·ªëi PeerJS ch∆∞a s·∫µn s√†ng. Vui l√≤ng ch·ªù.");
                    return;
                }
                if (!localStream) {
                    showError("Camera ch∆∞a s·∫µn s√†ng. Vui l√≤ng c·∫•p quy·ªÅn.");
                    return;
                }
                
                const code = codeInputs.map(input => input.value).join('').toUpperCase();
                
                if (code.length !== 6) {
                    showError("M√£ gh√©p ƒë√¥i ph·∫£i ƒë·ªß 6 ch·ªØ c√°i.");
                    return;
                }

                showStatus(`ƒêang k·∫øt n·ªëi ƒë·∫øn ${code}...`);
                btnConnect.disabled = true;
                btnConnectText.textContent = 'ƒêang k·∫øt n·ªëi...';
                
                const dataConn = peer.connect(code, { reliable: true });

                dataConn.on('open', () => {
                    console.log(`ƒê√£ m·ªü DataConnection ƒë·∫øn ${code}`);
                    showStatus('ƒê√£ k·∫øt n·ªëi data. ƒêang ch·ªù ch·∫•p nh·∫≠n...');
                    
                    dataConn.on('data', (data) => {
                        if (data === 'accepted') {
                            console.log("Admin ƒë√£ ch·∫•p nh·∫≠n. B·∫Øt ƒë·∫ßu g·ªçi video...");
                            showStatus('ƒê∆∞·ª£c ch·∫•p nh·∫≠n! ƒêang truy·ªÅn video...');
                            
                            const mediaCall = peer.call(code, localStream);
                            
                            mediaCall.on('stream', (remoteStream) => {
                                console.log("ƒê√£ nh·∫≠n l·∫°i stream t·ª´ admin (kh√¥ng mong ƒë·ª£i)", remoteStream);
                            });
                            
                            mediaCall.on('close', () => {
                                showStatus('K·∫øt n·ªëi video ƒë√£ ƒë√≥ng. S·∫µn s√†ng k·∫øt n·ªëi m·ªõi.');
                                btnConnect.disabled = false;
                                btnConnectText.textContent = 'K·∫øt n·ªëi';
                                entryForm.classList.remove('hidden'); // Hi·ªán l·∫°i form
                                btnToggleDetection.classList.remove('hidden'); // Hi·ªán l·∫°i n√∫t detect
                            });
                            
                            mediaCall.on('error', (err) => {
                                console.error("L·ªói MediaCall:", err);
                                showError(`L·ªói truy·ªÅn video: ${err.message}`);
                            });
                            
                            // T·∫Øt AI detection khi ƒëang stream
                            isDetectionRunning = false;
                            if (detectionInterval) clearInterval(detectionInterval);
                            detCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
                            btnToggleDetection.classList.add('hidden'); // ·∫®n n√∫t detect
                            
                            entryForm.classList.add('hidden'); // ·∫®n form sau khi k·∫øt n·ªëi
                        }
                    });
                });

                dataConn.on('error', (err) => {
                    console.error("L·ªói DataConnection:", err);
                    showError(`L·ªói k·∫øt n·ªëi data: ${err.message}`);
                    btnConnect.disabled = false;
                    btnConnectText.textContent = 'K·∫øt n·ªëi';
                });
                
                dataConn.on('close', () => {
                    console.log("DataConnection ƒë√£ ƒë√≥ng.");
                    if (statusText.textContent.includes('ƒêang truy·ªÅn video') === false) {
                        showStatus('K·∫øt n·ªëi b·ªã t·ª´ ch·ªëi ho·∫∑c ƒë√£ ƒë√≥ng.');
                        btnConnect.disabled = false;
                        btnConnectText.textContent = 'K·∫øt n·ªëi';
                    }
                });
            });
        }
        
        // --- CH·∫†Y KH·ªûI T·∫†O ---
        if (typeof Peer === 'undefined') {
            showError('L·ªói: Kh√¥ng th·ªÉ t·∫£i th∆∞ vi·ªán PeerJS. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ t·∫£i l·∫°i trang.');
        } else {
            initializePeer();
            startCamera(); // B·∫≠t camera ngay l·∫≠p t·ª©c
            loadModels();  // T·∫£i AI models
        }
    </script>
</body>
</html>

